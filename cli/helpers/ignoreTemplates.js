import fs from 'fs';
import path from 'path';
import os from 'os';
import https from 'https';
import chalk from 'chalk';

// Bundled templates for offline use and fast access
export const BUNDLED_TEMPLATES = {
    node: `# Node.js
Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime Data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# TypeScript v1 declaration files
typings/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variables file
.env
.env.test
.env.production

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next
out

# Nuxt.js build / generate output
.nuxt
dist

# Gatsby files
.cache/
# Comment in the public line in if your project uses Gatsby and not Next.js
# public

# vuepress build output
.vuepress/dist

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port

# Stores VSCode versions used for testing VSCode extensions
.vscode-test

# yarn v2
.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*
`,
    python: `# Python
# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class

# C extensions
*.so

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# PyInstaller
#  Usually these files are written by a python script from a template
#  before PyInstaller builds the exe, so as to inject date/other infos into it.
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/
cover/

# Translations
*.mo
*.pot

# Django stuff:
*.log
local_settings.py
db.sqlite3
db.sqlite3-journal

# Flask stuff:
instance/
.webassets-cache

# Scrapy stuff:
.scrapy

# Sphinx documentation
docs/_build/

# PyBuilder
.pybuilder/

# Jupyter Notebook
.ipynb_checkpoints

# IPython
profile_default/
ipython_config.py

# pyenv
.python-version

# pipenv
#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.
#   However, in case of collaboration, if having platform-specific dependencies or dependencies
#   with no cross-platform support, pipenv may install dependencies that don't work, or not
#   install all needed dependencies.
#Pipfile.lock

# poetry
#   Similar to Pipfile.lock, it is generally recommended to include poetry.lock in version control.
#   This is especially recommended for binary packages to ensure reproducible builds.
#   However, if you need to use different versions of the same library on different platforms,
#   you can exclude poetry.lock.
#poetry.lock

# pdm
#   Similar to Pipfile.lock, it is generally recommended to include pdm.lock in version control.
#pdm.lock
#   pdm stores project-wide configurations in .pdm.toml.
.pdm.toml
.pdm-python
.pdm-build/

# PEP 582; used by e.g. github.com/David-OConnor/pyflow and github.com/pdm-project/pdm
__pypackages__/

# Celery stuff
celerybeat-schedule
celerybeat.pid

# SageMath parsed files
*.sage.py

# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# Spyder project settings
.spyderproject
.spyproject

# Rope project settings
.ropeproject

# mkdocs documentation
/site

# mypy
.mypy_cache/
.dmypy.json
dmypy.json

# Pyre type checker
.pyre/

# pytype static type analyzer
.pytype/

# Cython debug symbols
cython_debug/

# PyCharm
#  JetBrains specific template is maintained in a separate JetBrains.gitignore that can
#  be found at https://github.com/github/gitignore/blob/main/Global/JetBrains.gitignore
#  and can be added to the global gitignore or merged into this file.  For a more
#  comprehensive list of editor ignore patterns, see Global/JetBrains.gitignore
.idea/
`,
    java: `# Java
# Compiled class file
*.class

# Log file
*.log

# BlueJ files
*.ctxt

# Mobile Tools for Java (J2ME)
.mtj.tmp/

# Package Files #
*.jar
*.war
*.nar
*.ear
*.zip
*.tar.gz
*.rar

# virtual machine crash logs, see http://www.java.com/en/download/help/error_hotspot.xml
hs_err_pid*
replay_pid*
`,
    go: `# Go
# Binaries for programs and plugins
*.exe
*.exe~
*.dll
*.so
*.dylib

# Test binary, built with 'go test -c'
*.test

# Output of the go coverage tool, specifically when used with LiteIDE
*.out

# Dependency directories (remove the comment below to include it)
# vendor/

# Go workspace file
go.work
`,
    react: `# React
node_modules/
build/
.env
.ds_store
dist/
coverage/
`,
    vscode: `# Visual Studio Code
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json
*.code-workspace
`,
    jetbrains: `# JetBrains (IntelliJ, PyCharm, WebStorm, etc.)
.idea/
*.iws
*.iml
out/
`,
    macos: `# macOS
.DS_Store
.AppleDouble
.LSOverride
._*
.DocumentRevisions-V100
.fseventsd
.Spotlight-V100
.TemporaryItems
.Trashes
.VolumeIcon.icns
.com.apple.timemachine.donotpresent
`,
    linux: `# Linux
*~
.fuse_hidden*
.directory
.Trash-*
.nfs*
`,
    cpp: `# C++
*.d
*.o
*.obj
*.exe
*.dll
*.so
*.dylib
*.ncb
*.sdf
*.suo
*.pdb
*.idb
*.ilk
*.aps
`
};

export class TemplateManager {
    constructor() {
        this.cacheDir = path.join(os.homedir(), '.gitgenie', 'templates');
        this.ensure
        this.ensureCacheDir();
    }

    ensureCacheDir() {
        if (!fs.existsSync(this.cacheDir)) {
            fs.mkdirSync(this.cacheDir, { recursive: true });
        }
    }

    /**
     * Get a template by name (bundled -> cache -> github)
     */
    async getTemplate(name) {
        const lowerName = name.toLowerCase();

        // 1. Check bundled templates
        if (BUNDLED_TEMPLATES[lowerName]) {
            return {
                source: 'bundled',
                content: BUNDLED_TEMPLATES[lowerName]
            };
        }

        // 2. Check cache
        const cacheFile = path.join(this.cacheDir, `${lowerName}.gitignore`);
        if (fs.existsSync(cacheFile)) {
            const stats = fs.statSync(cacheFile);
            const now = new Date();
            const daysSinceMod = (now - stats.mtime) / (1000 * 60 * 60 * 24);

            // If fresh (< 7 days), use cache
            if (daysSinceMod < 7) {
                return {
                    source: 'cache',
                    content: fs.readFileSync(cacheFile, 'utf-8')
                };
            }
            // If stale, try to update but fallback to cache if offline
        }

        // 3. Fetch from GitHub
        try {
            const content = await this.fetchFromGitHub(name);
            // Save to cache
            fs.writeFileSync(cacheFile, content, 'utf-8');
            return {
                source: 'github',
                content
            };
        } catch (err) {
            // If fetch failed but we have a stale cache, use it
            if (fs.existsSync(cacheFile)) {
                return {
                    source: 'cache (stale)',
                    content: fs.readFileSync(cacheFile, 'utf-8')
                };
            }
            throw err;
        }
    }

    fetchFromGitHub(name) {
        return new Promise((resolve, reject) => {
            // GitHub uses capitalized names usually, try exact first then capitalized
            // Common mapping: node -> Node, python -> Python
            const capitalized = name.charAt(0).toUpperCase() + name.slice(1);
            const url = `https://raw.githubusercontent.com/github/gitignore/main/${capitalized}.gitignore`;

            const req = https.get(url, (res) => {
                if (res.statusCode === 404) {
                    reject(new Error(`Template "${name}" not found on GitHub`));
                    return;
                }
                if (res.statusCode !== 200) {
                    reject(new Error(`Failed to fetch template: ${res.statusCode}`));
                    return;
                }

                let data = '';
                res.on('data', chunk => data += chunk);
                res.on('end', () => resolve(data));
            });

            req.on('error', (err) => {
                reject(new Error(`Network error: ${err.message}`));
            });

            req.on('timeout', () => {
                req.destroy();
                reject(new Error('Request timed out (5000ms)'));
            });

            req.setTimeout(5000);
        });
    }

    /**
     * List all available templates (bundled + cached)
     */
    listTemplates(filter = null) {
        const templates = new Set(Object.keys(BUNDLED_TEMPLATES));

        // Add cached templates
        if (fs.existsSync(this.cacheDir)) {
            fs.readdirSync(this.cacheDir).forEach(file => {
                if (file.endsWith('.gitignore')) {
                    templates.add(file.replace('.gitignore', ''));
                }
            });
        }

        const sorted = Array.from(templates).sort();

        if (filter) {
            return sorted.filter(t => t.includes(filter.toLowerCase()));
        }
        return sorted;
    }

    /**
     * Fuzzy match a template name
     */
    getClosestMatch(name) {
        const allTemplates = this.listTemplates();
        let closest = null;
        let minDistance = Infinity;

        for (const t of allTemplates) {
            const dist = this.levenshtein(name, t);
            if (dist < minDistance) {
                minDistance = dist;
                closest = t;
            }
        }

        // Only return if it's a reasonable match (e.g. within 3 edits)
        return minDistance <= 3 ? closest : null;
    }

    // Levenshtein distance implementation
    levenshtein(a, b) {
        if (a.length === 0) return b.length;
        if (b.length === 0) return a.length;

        const matrix = [];

        // increment along the first column of each row
        var i;
        for (i = 0; i <= b.length; i++) {
            matrix[i] = [i];
        }

        // increment each column in the first row
        var j;
        for (j = 0; j <= a.length; j++) {
            matrix[0][j] = j;
        }

        // Fill in the rest of the matrix
        for (i = 1; i <= b.length; i++) {
            for (j = 1; j <= a.length; j++) {
                if (b.charAt(i - 1) == a.charAt(j - 1)) {
                    matrix[i][j] = matrix[i - 1][j - 1];
                } else {
                    matrix[i][j] = Math.min(
                        matrix[i - 1][j - 1] + 1, // substitution
                        Math.min(
                            matrix[i][j - 1] + 1, // insertion
                            matrix[i - 1][j] + 1 // deletion
                        )
                    );
                }
            }
        }

        return matrix[b.length][a.length];
    }
}
